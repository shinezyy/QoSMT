diff --git a/src/cpu/o3/cpu.cc b/src/cpu/o3/cpu.cc
index 17e940c..cd0730f 100644
--- a/src/cpu/o3/cpu.cc
+++ b/src/cpu/o3/cpu.cc
@@ -304,6 +304,11 @@ FullO3CPU<Impl>::FullO3CPU(DerivO3CPUParams *params)
             // Note that we can't use the rename() method because we don't
             // want special treatment for the zero register at this point
             PhysRegIndex phys_reg = freeList.getIntReg();
+            // FIXME Ugly exposure. Due to the assignment, the free reg
+            // counter per thread has to be substracted to keep the
+            // consistency.
+            rename.nrFreeRegs[tid]--;
+
             renameMap[tid].setIntEntry(ridx, phys_reg);
             commitRenameMap[tid].setIntEntry(ridx, phys_reg);
         }
@@ -627,6 +632,7 @@ FullO3CPU<Impl>::init()
     commit.setThreads(thread);
     resourceManager.setIQ(&iew.instQueue);
     resourceManager.setROB(commit.rob);
+    resourceManager.setRename(&rename);
 }
 
 template <class Impl>
@@ -645,6 +651,7 @@ FullO3CPU<Impl>::startup()
     resourceManager.readConfig();
     resourceManager.reserveIQ();
     resourceManager.reserveROB();
+    resourceManager.reserveRename();
     resourceManager.reconfigIssuePrio();
 }
 
diff --git a/src/cpu/o3/rename.hh b/src/cpu/o3/rename.hh
index a543cef..936acb5 100644
--- a/src/cpu/o3/rename.hh
+++ b/src/cpu/o3/rename.hh
@@ -511,6 +511,13 @@ class DefaultRename
     Stats::Scalar renamedTempSerializing;
     /** Number of instructions inserted into skid buffers. */
     Stats::Scalar renameSkidInsts;
+
+  public:
+    /** The number of available free physical regs for each thread
+     * and its initial value indicates the maximum number. */
+    unsigned nrFreeRegs[Impl::MaxThreads];
+
+    void setNrFreeRegs(unsigned _nrFreeRegs[], ThreadID _numThreads);
 };
 
 #endif // __CPU_O3_RENAME_HH__
diff --git a/src/cpu/o3/rename_impl.hh b/src/cpu/o3/rename_impl.hh
index 7bf33d3..a1089d7 100644
--- a/src/cpu/o3/rename_impl.hh
+++ b/src/cpu/o3/rename_impl.hh
@@ -78,6 +78,10 @@ DefaultRename<Impl>::DefaultRename(O3CPU *_cpu, DerivO3CPUParams *params)
 
     // @todo: Make into a parameter.
     skidBufferMax = (decodeToRenameDelay + 1) * params->decodeWidth;
+
+    for (int i = 0; i < sizeof(this->nrFreeRegs) / sizeof(this->nrFreeRegs[0]); i++) {
+        nrFreeRegs[i] = 0;
+    }
 }
 
 template <class Impl>
@@ -633,9 +637,10 @@ DefaultRename<Impl>::renameInsts(ThreadID tid)
 
         // Check here to make sure there are enough destination registers
         // to rename to.  Otherwise block.
-        if (!renameMap[tid]->canRename(inst->numIntDestRegs(),
-                                       inst->numFPDestRegs(),
-                                       inst->numCCDestRegs())) {
+        if (!(renameMap[tid]->canRename(inst->numIntDestRegs(),
+                                        inst->numFPDestRegs(),
+                                        inst->numCCDestRegs())
+              && nrFreeRegs[tid] >= inst->numIntDestRegs())) { // can handle 0
             DPRINTF(Rename, "Blocking due to lack of free "
                     "physical registers to rename to.\n");
             blockThisCycle = true;
@@ -927,6 +932,7 @@ DefaultRename<Impl>::doSquash(const InstSeqNum &squashed_seq_num, ThreadID tid)
 
             // Put the renamed physical register back on the free list.
             freeList->addReg(hb_it->newPhysReg);
+            nrFreeRegs[tid]++;
         }
 
         historyBuffer[tid].erase(hb_it++);
@@ -974,6 +980,7 @@ DefaultRename<Impl>::removeFromHistory(InstSeqNum inst_seq_num, ThreadID tid)
         // the old one.
         if (hb_it->newPhysReg != hb_it->prevPhysReg) {
             freeList->addReg(hb_it->prevPhysReg);
+            nrFreeRegs[tid]++;
         }
 
         ++renameCommittedMaps;
@@ -1068,6 +1075,8 @@ DefaultRename<Impl>::renameDestRegs(DynInstPtr &inst, ThreadID tid)
             flat_rel_dest_reg = tc->flattenIntIndex(rel_dest_reg);
             rename_result = map->renameInt(flat_rel_dest_reg);
             flat_uni_dest_reg = flat_rel_dest_reg;  // 1:1 mapping
+            nrFreeRegs[tid]--;
+            assert(nrFreeRegs[tid] >= 0);
             break;
 
           case FloatRegClass:
@@ -1422,4 +1431,18 @@ DefaultRename<Impl>::dumpHistory()
     }
 }
 
+template <class Impl>
+void
+DefaultRename<Impl>::setNrFreeRegs(unsigned _nrFreeRegs[], ThreadID _numThreads)
+{
+    assert(_numThreads == this->numThreads);
+    for (ThreadID tid = 0; tid < _numThreads; ++tid) {
+        // Use `+=' to work around with the pre-assignment for architectual regs.
+        // nrFreeRegs[tid] might become negtive in that procedure.
+        nrFreeRegs[tid] += _nrFreeRegs[tid];
+    }
+    // TODO Support set in runtime, which needs more checks for correctness.
+    // TODO Support more register classes.
+}
+
 #endif//__CPU_O3_RENAME_IMPL_HH__
diff --git a/src/cpu/o3/resource_manager.hh b/src/cpu/o3/resource_manager.hh
index a589e9c..e8aa8ee 100644
--- a/src/cpu/o3/resource_manager.hh
+++ b/src/cpu/o3/resource_manager.hh
@@ -13,6 +13,7 @@ class ResourceManager {
     typedef typename Impl::O3CPU O3CPU;
     typedef typename CPUPol::IQ IQ;
     typedef typename CPUPol::ROB ROB;
+    typedef typename CPUPol::Rename Rename;
 
     private:
 
@@ -22,6 +23,8 @@ class ResourceManager {
 
         O3CPU *cpu;
 
+        Rename *rename;
+
         // TODO Document is a typedef, so we cannot pre-declare it...
         rapidjson::Document config;
 
@@ -37,10 +40,14 @@ class ResourceManager {
 
         void setROB(ROB *_rob);
 
+        void setRename(Rename *_rename);
+
         void reserveIQ();
 
         void reserveROB();
 
+        void reserveRename();
+
         void reconfigIssuePrio();
 
         bool readConfig();
diff --git a/src/cpu/o3/resource_manager_impl.hh b/src/cpu/o3/resource_manager_impl.hh
index 72c38eb..98bc3b6 100644
--- a/src/cpu/o3/resource_manager_impl.hh
+++ b/src/cpu/o3/resource_manager_impl.hh
@@ -22,6 +22,13 @@ ResourceManager<Impl>::name() const
 
 template<class Impl>
 void
+ResourceManager<Impl>::setRename(Rename *_rename)
+{
+    rename = _rename;
+}
+
+template<class Impl>
+void
 ResourceManager<Impl>::setIQ(IQ *_instQueue)
 {
     instQueue = _instQueue;
@@ -118,6 +125,35 @@ ResourceManager<Impl>::reconfigIssuePrio()
 }
 
 
+template <class Impl>
+void
+ResourceManager<Impl>::reserveRename()
+{
+    ThreadID numThreads = cpu->numThreads;
+    auto freeRegArray = new unsigned[numThreads];
+    if (configUpdated && config.HasMember("FreeRegs")) {
+        auto freeRegArrayAst = config["FreeRegs"].GetArray();
+        // TODO Add support for default value, or auto evaluated
+        // from freeList.size()
+        for (ThreadID tid = 0; tid < numThreads; ++tid) {
+            freeRegArray[tid] = freeRegArrayAst[tid].GetInt();
+        }
+    }
+    else {
+        for (ThreadID tid = 0; tid < numThreads; ++tid) {
+            // This assignment has no semantic meaning, and seems RIDICULOUS,
+            // but it will make the limit check always true.
+            // So that we can close this feature without additional
+            // condition judgement.
+            freeRegArray[tid] = cpu->regFile.numIntPhysRegisters;
+        }
+    }
+
+    rename->setNrFreeRegs(freeRegArray, numThreads);
+    delete[] freeRegArray;
+}
+
+
 template<class Impl>
 bool
 ResourceManager<Impl>::readConfig()
